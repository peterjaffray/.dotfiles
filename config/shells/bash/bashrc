# ~/.bashrc: executed by bash(1) for non-login shells.
# See /usr/share/doc/bash/examples/startup-files for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# Source common shell configurations
DOTFILES_DIR="${HOME}/.dotfiles/config"
COMMON_DIR="${DOTFILES_DIR}/shells/common"

# Load common exports first (needed by other configs)
[ -f "$COMMON_DIR/exports" ] && source "$COMMON_DIR/exports"

# Load common path configuration
[ -f "$COMMON_DIR/paths" ] && source "$COMMON_DIR/paths"

# Load common functions
[ -f "$COMMON_DIR/functions" ] && source "$COMMON_DIR/functions"

# Load common aliases
[ -f "$COMMON_DIR/aliases" ] && source "$COMMON_DIR/aliases"

# Bash-specific configurations
# History settings (enhanced from common exports)
shopt -s histappend
HISTCONTROL=ignoreboth:erasedups
HISTSIZE=10000
HISTFILESIZE=20000

# Update window size after each command
shopt -s checkwinsize

# Enable programmable completion features
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# Enable vim mode
set -o vi

# Enhanced completion settings
bind 'set completion-ignore-case on'
bind 'set completion-map-case on'
bind 'set show-all-if-ambiguous on'
bind 'set show-all-if-unmodified on'
bind 'set menu-complete-display-prefix on'
bind 'TAB:menu-complete'
bind '"\e[Z":menu-complete-backward'

# Enable color support for ls
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
fi

# Colored GCC warnings and errors
export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# Vim mode and git branch for prompt - DISABLED (configured in main .bashrc)
# parse_git_branch() {
#     local branch=$(git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
#     if [ -n "$branch" ]; then
#         echo " ($branch)"
#     fi
# }
#
# show_vim_mode() {
#     case "${BASH_KEYMAP:-emacs}" in
#         vi-ins) echo -e "\[\033[01;32m\][i]" ;;
#         vi-cmd) echo -e "\[\033[01;37m\][n]" ;;
#         *) echo -e "\[\033[01;32m\][i]" ;;
#     esac
# }
#
# set_prompt() {
#     PS1="$(show_vim_mode)\[\033[01;36m\](bash)$(parse_git_branch)\[\033[00m\]> "
# }
#
# # Update prompt on keymap change
# bind 'set show-mode-in-prompt on'
# PROMPT_COMMAND=set_prompt

# Powerline prompt (disabled for custom prompt)
# if command -v powerline-daemon >/dev/null 2>&1; then
#     powerline-daemon -q
#     POWERLINE_BASH_CONTINUATION=1
#     POWERLINE_BASH_SELECT=1
#     if [ -f /usr/share/powerline/bindings/bash/powerline.sh ]; then
#         source /usr/share/powerline/bindings/bash/powerline.sh
#     elif [ -f ~/.local/lib/python*/site-packages/powerline/bindings/bash/powerline.sh ]; then
#         source ~/.local/lib/python*/site-packages/powerline/bindings/bash/powerline.sh
#     fi
# fi

# Tool initializations (lazy loading for performance)
# NVM (Node Version Manager)
if [ -d "$NVM_DIR" ]; then
    nvm() {
        unset -f nvm
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
        nvm "$@"
    }
fi

# pyenv (Python Version Manager) - lazy loading
if [ -d "$PYENV_ROOT" ]; then
    pyenv() {
        unset -f pyenv
        eval "$(command pyenv init -)"
        eval "$(command pyenv virtualenv-init -)"
        pyenv "$@"
    }
fi

# rbenv (Ruby Version Manager) - lazy loading
if [ -d "${HOME}/.rbenv" ]; then
    rbenv() {
        unset -f rbenv
        eval "$(command rbenv init -)"
        rbenv "$@"
    }
fi

# FZF key bindings
if command -v fzf >/dev/null 2>&1; then
    # Key bindings
    if [ -f /usr/share/doc/fzf/examples/key-bindings.bash ]; then
        source /usr/share/doc/fzf/examples/key-bindings.bash
    elif [ -f ~/.fzf/shell/key-bindings.bash ]; then
        source ~/.fzf/shell/key-bindings.bash
    fi
    
    # Auto-completion
    if [ -f /usr/share/doc/fzf/examples/completion.bash ]; then
        source /usr/share/doc/fzf/examples/completion.bash
    elif [ -f ~/.fzf/shell/completion.bash ]; then
        source ~/.fzf/shell/completion.bash
    fi
fi

# Useful functions
mkcd() {
    mkdir -p "$1" && cd "$1"
}

up() {
    local count=${1:-1}
    local path=""
    for ((i=0; i<count; i++)); do
        path="../$path"
    done
    cd "$path"
}

extract() {
    if [ $# -eq 0 ]; then
        echo "Usage: extract <archive_file>"
        return 1
    fi
    
    if [ ! -f "$1" ]; then
        echo "Error: '$1' is not a valid file"
        return 1
    fi
    
    case "$1" in
        *.tar.gz|*.tgz) tar xzf "$1" ;;
        *.tar.bz2|*.tbz2) tar xjf "$1" ;;
        *.tar.xz|*.txz) tar xJf "$1" ;;
        *.tar) tar xf "$1" ;;
        *.zip) unzip "$1" ;;
        *.rar) unrar x "$1" ;;
        *.7z) 7z x "$1" ;;
        *.gz) gunzip "$1" ;;
        *.bz2) bunzip2 "$1" ;;
        *.xz) unxz "$1" ;;
        *) echo "Error: Unknown archive format for '$1'"; return 1 ;;
    esac
}

# Git aliases
alias g='git'
alias gc='git commit'
alias gst='git status'
alias gco='git checkout'
alias gp='git push'
alias gl='git pull'
alias gd='git diff'
alias ga='git add'
alias gb='git branch'
alias glog='git log --oneline --graph --decorate'

# Directory aliases
alias ll='ls -lah'
alias la='ls -A'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

# System aliases
alias df='df -h'
alias du='du -h'
alias free='free -h'

# Docker aliases
alias dc='docker compose'
alias dps='docker ps'

# Editor aliases
alias v='nvim'
alias vi='nvim'
alias vim='nvim'

# Documentation system - use 'h' as alternative to '?'
h() {
    help-system "$@"
}

# Note: ? function disabled in bash due to syntax issues

# Load machine-specific bash configuration
MACHINE_BASHRC="${DOTFILES_DIR}/machines/current/bashrc"
if [ -f "$MACHINE_BASHRC" ]; then
    source "$MACHINE_BASHRC"
fi

# Load local bash configuration (not version controlled)
if [ -f ~/.bashrc.local ]; then
    source ~/.bashrc.local
fi

# Initialize dotfiles management command completion
if [ -f "${HOME}/.local/bin/dotfiles" ]; then
    complete -W "status sync backup restore diff add machine test secrets scripts help" dotfiles
fi

export LANG=en_CA.UTF-8
export LC_ALL=en_CA.UTF-8

# Rust setup (if installed)
[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"
