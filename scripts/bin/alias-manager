#!/bin/bash
# Alias Manager - Cross-shell alias management for dotfiles
# Replaces the old add-alias tool with better integration and conflict detection

VERSION="1.0"
DOTFILES_ROOT="${HOME}/.dotfiles"
ALIASES_FILE="${DOTFILES_ROOT}/config/shells/common/aliases"
FISH_CONF_DIR="${DOTFILES_ROOT}/config/shells/fish/conf.d"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Usage information
show_help() {
    cat << EOF
Alias Manager v$VERSION - Cross-shell alias management

Usage: alias-manager <command> [options] [arguments]

Commands:
    add NAME COMMAND              Add new alias
    add --safe NAME COMMAND       Add with install message if command missing
    add --fallback NAME CMD FALL  Add with fallback command
    remove NAME                   Remove alias from all shells
    list                         Show all aliases with availability
    check                        Validate all aliases and show issues
    conflicts NAME               Check if alias name conflicts with existing commands
    reload                       Reload aliases in current shell
    help                         Show this help message

Options:
    --fallback COMMAND           Fallback command if primary isn't available
    --install MESSAGE            Message to show if command isn't installed
    --force                      Skip conflict checks
    --dry-run                   Show what would be done

Examples:
    alias-manager add ll "ls -lah"
    alias-manager add cat "bat" --fallback="cat" --install="Install bat: brew install bat"
    alias-manager add --safe k "kubectl" --install="Install kubectl from k8s.io"
    alias-manager remove ll
    alias-manager list
    alias-manager check

The tool manages aliases in: $ALIASES_FILE
Fish integration: $FISH_CONF_DIR/00-aliases.fish
EOF
}

# Logging functions
log() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

success() {
    echo -e "${GREEN}✓${NC} $*"
}

# Check if alias name conflicts with existing commands
check_conflicts() {
    local name="$1"
    local force="$2"
    
    # Check if it's a shell builtin
    if type "$name" >/dev/null 2>&1; then
        local cmd_type=$(type "$name" 2>/dev/null)
        
        if [[ "$cmd_type" =~ "is a shell builtin" ]]; then
            warn "Alias '$name' will override shell builtin command"
            if [ "$force" != "true" ]; then
                read -p "Continue anyway? (y/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    return 1
                fi
            fi
        elif [[ "$cmd_type" =~ "is aliased to" ]] || [[ "$cmd_type" =~ "is a function" ]]; then
            warn "Alias '$name' already exists"
            if [ "$force" != "true" ]; then
                read -p "Replace it? (y/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    return 1
                fi
            fi
        elif command -v "$name" >/dev/null 2>&1; then
            warn "Alias '$name' will override existing command: $(which "$name" 2>/dev/null || echo "builtin")"
            if [ "$force" != "true" ]; then
                read -p "Continue anyway? (y/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    return 1
                fi
            fi
        fi
    fi
    
    return 0
}

# Add alias to the common aliases file
add_alias() {
    local name="$1"
    local command="$2"
    local fallback="$3"
    local install_msg="$4"
    local safe_mode="$5"
    local force="$6"
    local dry_run="$7"
    
    # Validate inputs
    if [ -z "$name" ] || [ -z "$command" ]; then
        error "Both alias name and command are required"
        return 1
    fi
    
    # Validate alias name
    if [[ ! "$name" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
        error "Invalid alias name: '$name'"
        error "Alias names must start with a letter or underscore and contain only alphanumeric characters and underscores"
        return 1
    fi
    
    # Check for conflicts
    if ! check_conflicts "$name" "$force"; then
        log "Alias addition cancelled"
        return 1
    fi
    
    # Build the alias line
    local alias_line
    if [ "$safe_mode" = "true" ] && [ -n "$install_msg" ]; then
        alias_line="safe_alias $name \"$command\" \"$fallback\" \"$install_msg\""
    elif [ -n "$fallback" ]; then
        alias_line="safe_alias $name \"$command\" \"$fallback\" \"\""
    else
        alias_line="alias $name='$command'"
    fi
    
    if [ "$dry_run" = "true" ]; then
        log "Would add to $ALIASES_FILE:"
        echo "$alias_line"
        return 0
    fi
    
    # Create backup
    if [ -f "$ALIASES_FILE" ]; then
        cp "$ALIASES_FILE" "${ALIASES_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
    fi
    
    # Remove existing alias if it exists
    remove_alias_from_file "$name" quiet
    
    # Add new alias
    echo >> "$ALIASES_FILE"
    echo "# Added by alias-manager on $(date)" >> "$ALIASES_FILE"
    echo "$alias_line" >> "$ALIASES_FILE"
    
    success "Alias '$name' added successfully!"
    log "Command: $command"
    [ -n "$fallback" ] && log "Fallback: $fallback"
    [ -n "$install_msg" ] && log "Install help: $install_msg"
    
    # Reload current shell
    reload_aliases
}

# Remove alias from file (internal function)
remove_alias_from_file() {
    local name="$1"
    local quiet="$2"
    
    if [ ! -f "$ALIASES_FILE" ]; then
        [ "$quiet" != "quiet" ] && error "Aliases file not found: $ALIASES_FILE"
        return 1
    fi
    
    # Remove both regular alias and safe_alias lines
    local temp_file=$(mktemp)
    grep -v "^alias $name=" "$ALIASES_FILE" | \
    grep -v "^safe_alias $name " > "$temp_file"
    mv "$temp_file" "$ALIASES_FILE"
    
    # Remove comments added by alias-manager for this alias
    temp_file=$(mktemp)
    awk "
        /^# Added by alias-manager/ { 
            getline next_line
            if (next_line !~ /^(alias|safe_alias) $name[ =]/) {
                print
                print next_line
            }
            next
        }
        { print }
    " "$ALIASES_FILE" > "$temp_file"
    mv "$temp_file" "$ALIASES_FILE"
}

# Remove alias completely
remove_alias() {
    local name="$1"
    local dry_run="$2"
    
    if [ -z "$name" ]; then
        error "Alias name required"
        return 1
    fi
    
    if ! grep -q "^alias $name=\|^safe_alias $name " "$ALIASES_FILE" 2>/dev/null; then
        error "Alias '$name' not found in $ALIASES_FILE"
        return 1
    fi
    
    if [ "$dry_run" = "true" ]; then
        log "Would remove alias '$name' from $ALIASES_FILE"
        return 0
    fi
    
    # Create backup
    cp "$ALIASES_FILE" "${ALIASES_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
    
    # Remove from file
    remove_alias_from_file "$name"
    
    success "Removed alias '$name'"
    
    # Reload current shell
    reload_aliases
}

# List all aliases with availability status
list_aliases() {
    log "Cross-shell aliases from $ALIASES_FILE:"
    echo
    
    if [ ! -f "$ALIASES_FILE" ]; then
        warn "No aliases file found"
        return
    fi
    
    # Parse and display aliases
    while IFS= read -r line; do
        if [[ "$line" =~ ^alias\ ([^=]+)=\'?(.+)\'?$ ]]; then
            local name="${BASH_REMATCH[1]}"
            local cmd="${BASH_REMATCH[2]}"
            local status="✓"
            local color="$GREEN"
            
            # Check if command exists
            local first_cmd="${cmd%% *}"
            if ! command -v "$first_cmd" >/dev/null 2>&1; then
                status="✗"
                color="$RED"
            fi
            
            echo -e "${color}${status}${NC} $name → $cmd"
            
        elif [[ "$line" =~ ^safe_alias\ ([^[:space:]]+)\ \"([^\"]+)\"\ \"([^\"]*)\".* ]]; then
            local name="${BASH_REMATCH[1]}"
            local cmd="${BASH_REMATCH[2]}"
            local fallback="${BASH_REMATCH[3]}"
            
            local first_cmd="${cmd%% *}"
            if command -v "$first_cmd" >/dev/null 2>&1; then
                echo -e "${GREEN}✓${NC} $name → $cmd"
            elif [ -n "$fallback" ] && command -v "${fallback%% *}" >/dev/null 2>&1; then
                echo -e "${YELLOW}⚠${NC} $name → $fallback (fallback)"
            else
                echo -e "${RED}✗${NC} $name → $cmd (missing)"
            fi
        fi
    done < "$ALIASES_FILE"
    
    echo
    log "Legend: ${GREEN}✓${NC} Available  ${YELLOW}⚠${NC} Fallback  ${RED}✗${NC} Missing"
}

# Check alias health
check_aliases() {
    local issues=0
    
    log "Checking alias health..."
    echo
    
    if [ ! -f "$ALIASES_FILE" ]; then
        error "Aliases file not found: $ALIASES_FILE"
        return 1
    fi
    
    while IFS= read -r line; do
        if [[ "$line" =~ ^alias\ ([^=]+)=\'?(.+)\'?$ ]]; then
            local name="${BASH_REMATCH[1]}"
            local cmd="${BASH_REMATCH[2]}"
            local first_cmd="${cmd%% *}"
            
            if ! command -v "$first_cmd" >/dev/null 2>&1; then
                error "Alias '$name': Command '$first_cmd' not found"
                ((issues++))
            fi
        elif [[ "$line" =~ ^safe_alias\ ([^[:space:]]+)\ \"([^\"]+)\".* ]]; then
            local name="${BASH_REMATCH[1]}"
            local cmd="${BASH_REMATCH[2]}"
            local first_cmd="${cmd%% *}"
            
            if ! command -v "$first_cmd" >/dev/null 2>&1; then
                warn "Safe alias '$name': Primary command '$first_cmd' not found (expected)"
            fi
        fi
    done < "$ALIASES_FILE"
    
    if [ $issues -eq 0 ]; then
        success "All aliases are healthy!"
    else
        error "$issues issues found"
    fi
    
    return $issues
}

# Reload aliases in current shell
reload_aliases() {
    log "Reloading aliases..."
    
    if [ -f "$ALIASES_FILE" ]; then
        # shellcheck source=/dev/null
        source "$ALIASES_FILE" 2>/dev/null || warn "Some aliases may not have loaded properly"
        success "Aliases reloaded"
    else
        warn "No aliases file to reload"
    fi
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        add)
            local safe_mode=false
            local force=false
            local dry_run=false
            local fallback=""
            local install_msg=""
            local name=""
            local cmd=""
            
            # Parse options
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --safe)
                        safe_mode=true
                        shift
                        ;;
                    --fallback)
                        fallback="$2"
                        shift 2
                        ;;
                    --install)
                        install_msg="$2"
                        shift 2
                        ;;
                    --force)
                        force=true
                        shift
                        ;;
                    --dry-run)
                        dry_run=true
                        shift
                        ;;
                    -*)
                        error "Unknown option: $1"
                        exit 1
                        ;;
                    *)
                        if [ -z "$name" ]; then
                            name="$1"
                        elif [ -z "$cmd" ]; then
                            cmd="$1"
                        else
                            error "Too many arguments"
                            exit 1
                        fi
                        shift
                        ;;
                esac
            done
            
            add_alias "$name" "$cmd" "$fallback" "$install_msg" "$safe_mode" "$force" "$dry_run"
            ;;
        remove)
            local dry_run=false
            local name=""
            
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --dry-run)
                        dry_run=true
                        shift
                        ;;
                    -*)
                        error "Unknown option: $1"
                        exit 1
                        ;;
                    *)
                        name="$1"
                        shift
                        ;;
                esac
            done
            
            remove_alias "$name" "$dry_run"
            ;;
        list)
            list_aliases
            ;;
        check)
            check_aliases
            ;;
        conflicts)
            if [ -z "$1" ]; then
                error "Alias name required"
                exit 1
            fi
            check_conflicts "$1" false
            ;;
        reload)
            reload_aliases
            ;;
        help|--help)
            show_help
            ;;
        *)
            error "Unknown command: $command"
            echo
            show_help
            exit 1
            ;;
    esac
}

# Run main function
main "$@"