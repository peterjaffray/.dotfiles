#!/bin/bash
# Dotfiles Management Command - Central management for dotfiles and scripts
# Provides a unified interface for managing your entire dotfiles system

set -e

VERSION="1.0"
DOTFILES_ROOT="${HOME}/.dotfiles"
CONFIG_DIR="$DOTFILES_ROOT/config"
SCRIPTS_DIR="$DOTFILES_ROOT/scripts"
LIB_DIR="$DOTFILES_ROOT/system"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Import libraries
if [ -f "$LIB_DIR/backup-manager.sh" ]; then
    source "$LIB_DIR/backup-manager.sh"
fi

if [ -f "$LIB_DIR/machine-detector.sh" ]; then
    source "$LIB_DIR/machine-detector.sh"
fi

if [ -f "$LIB_DIR/symlink-manager.sh" ]; then
    source "$LIB_DIR/symlink-manager.sh"
fi

if [ -f "$LIB_DIR/secret-manager.sh" ]; then
    source "$LIB_DIR/secret-manager.sh"
fi

# Usage information
show_help() {
    cat << EOF
Dotfiles Management Command v$VERSION

Usage: dotfiles <command> [options]

Commands:
    status              Show current dotfiles status
    sync                Sync with remote repository
    backup              Create backup of current configuration
    restore [backup]    Restore from backup
    diff                Show local modifications
    add <file>          Add file to dotfiles management
    machine             Show/manage machine configuration
    test                Validate configuration
    install             Run installer
    update              Update dotfiles system
    clean               Clean up broken symlinks and old backups

Secret Management:
    secrets <cmd>       Manage secrets (init|add|list|etc.)

Script Management:  
    scripts <cmd>       Manage utility scripts (list|add|etc.)

Symlink Management:
    links <cmd>         Manage symlinks (list|verify|etc.)

System Information:
    info                Show system and dotfiles information
    doctor              Run system diagnostics
    version             Show version information
    help                Show this help message

Examples:
    dotfiles status                    # Show current status
    dotfiles sync                      # Sync with git repository
    dotfiles add ~/.vimrc              # Add file to management
    dotfiles machine show              # Show machine profile
    dotfiles secrets init              # Initialize secrets
    dotfiles scripts list              # List available scripts
    dotfiles links verify             # Verify symlink integrity
    dotfiles backup                    # Create full backup
    dotfiles doctor                    # Check system health

For detailed help on subcommands, use:
    dotfiles <command> --help

Configuration Directory: $CONFIG_DIR
Dotfiles Directory: $DOTFILES_DIR
EOF
}

# Logging functions
log() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

success() {
    echo -e "${GREEN}âœ“${NC} $*"
}

verbose() {
    echo -e "${CYAN}[DEBUG]${NC} $*"
}

# Check if we're in a git repository
is_git_repo() {
    git -C "$CONFIG_DIR" rev-parse --git-dir >/dev/null 2>&1
}

# Show current status
show_status() {
    echo -e "${BLUE}Dotfiles Status${NC}"
    echo "==============="
    
    # Basic information
    echo "Config Directory: $CONFIG_DIR"
    echo "Dotfiles Directory: $DOTFILES_DIR"
    echo "Scripts Directory: $SCRIPTS_DIR"
    
    # Git status
    if is_git_repo; then
        echo -e "\n${BLUE}Git Status:${NC}"
        git -C "$CONFIG_DIR" status --porcelain | head -10
        
        local branch
        branch=$(git -C "$CONFIG_DIR" branch --show-current 2>/dev/null || echo "unknown")
        echo "Current branch: $branch"
        
        # Check for uncommitted changes
        if ! git -C "$CONFIG_DIR" diff --quiet 2>/dev/null; then
            warn "Uncommitted changes found"
        fi
        
        # Check for untracked files
        if [ -n "$(git -C "$CONFIG_DIR" ls-files --others --exclude-standard 2>/dev/null)" ]; then
            warn "Untracked files found"
        fi
    else
        warn "Not a git repository"
    fi
    
    # Machine information
    echo -e "\n${BLUE}Machine:${NC}"
    if command -v get_machine_value >/dev/null 2>&1; then
        echo "ID: $(get_machine_value machine_id)"
        echo "OS: $(get_machine_value os) $(get_machine_value distro)"
        echo "Role: $(get_machine_value role)"
    else
        echo "Machine detection not available"
    fi
    
    # Symlinks status
    echo -e "\n${BLUE}Symlinks:${NC}"
    if command -v list_symlinks >/dev/null 2>&1; then
        local symlink_count
        symlink_count=$(list_symlinks "" "csv" 2>/dev/null | tail -n +2 | wc -l)
        echo "Managed symlinks: $symlink_count"
        
        # Check for broken symlinks
        local broken_count
        broken_count=$(list_symlinks "" "csv" 2>/dev/null | grep -c ",missing" || echo "0")
        if [ "$broken_count" -gt 0 ]; then
            warn "$broken_count broken symlinks found"
        fi
    else
        echo "Symlink management not available"
    fi
    
    # Backup status
    echo -e "\n${BLUE}Backups:${NC}"
    if [ -d "$CONFIG_DIR/backups" ]; then
        local backup_count
        backup_count=$(find "$CONFIG_DIR/backups" -name "*.backup.*" -type f | wc -l)
        echo "Available backups: $backup_count"
        
        if [ "$backup_count" -gt 0 ]; then
            local latest_backup
            latest_backup=$(find "$CONFIG_DIR/backups" -name "*.backup.*" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2- | xargs basename)
            echo "Latest backup: $latest_backup"
        fi
    else
        echo "No backups directory"
    fi
    
    # Scripts status
    echo -e "\n${BLUE}Scripts:${NC}"
    if [ -d "$SCRIPTS_DIR/bin" ]; then
        local script_count
        script_count=$(find "$SCRIPTS_DIR/bin" -type f -executable | wc -l)
        echo "Available scripts: $script_count"
    else
        echo "No scripts directory"
    fi
}

# Sync with remote repository
sync_dotfiles() {
    if ! is_git_repo; then
        error "Not a git repository"
        return 1
    fi
    
    log "Syncing dotfiles with remote repository..."
    
    # Check for uncommitted changes
    if ! git -C "$CONFIG_DIR" diff --quiet; then
        warn "You have uncommitted changes"
        read -p "Stash changes and continue? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            git -C "$CONFIG_DIR" stash
            log "Changes stashed"
        else
            error "Sync cancelled"
            return 1
        fi
    fi
    
    # Fetch and merge
    git -C "$CONFIG_DIR" fetch origin
    
    local current_branch
    current_branch=$(git -C "$CONFIG_DIR" branch --show-current)
    
    if git -C "$CONFIG_DIR" merge-tree "$(git -C "$CONFIG_DIR" merge-base HEAD origin/$current_branch)" HEAD "origin/$current_branch" | grep -q .; then
        warn "Merge conflicts detected"
        log "Manual resolution required"
        git -C "$CONFIG_DIR" merge "origin/$current_branch"
    else
        git -C "$CONFIG_DIR" merge --ff-only "origin/$current_branch"
        success "Sync completed successfully"
    fi
    
    # Verify symlinks after sync
    if command -v verify_symlinks >/dev/null 2>&1; then
        log "Verifying symlinks after sync..."
        verify_symlinks
    fi
}

# Create backup
backup_dotfiles() {
    log "Creating dotfiles backup..."
    
    if command -v backup_main >/dev/null 2>&1; then
        # Backup key dotfiles
        backup_main create \
            "$HOME/.bashrc" \
            "$HOME/.profile" \
            "$HOME/.gitconfig" \
            "$HOME/.tmux.conf" \
            "$CONFIG_DIR" 2>/dev/null || true
    else
        # Fallback manual backup
        local timestamp
        timestamp=$(date +%Y%m%d_%H%M%S)
        local backup_dir="$HOME/.dotfiles-backup-$timestamp"
        
        mkdir -p "$backup_dir"
        
        # Copy important files
        [ -f "$HOME/.bashrc" ] && cp "$HOME/.bashrc" "$backup_dir/"
        [ -f "$HOME/.profile" ] && cp "$HOME/.profile" "$backup_dir/"
        [ -f "$HOME/.gitconfig" ] && cp "$HOME/.gitconfig" "$backup_dir/"
        [ -f "$HOME/.tmux.conf" ] && cp "$HOME/.tmux.conf" "$backup_dir/"
        
        # Copy config directory
        cp -r "$CONFIG_DIR" "$backup_dir/config"
        
        success "Backup created: $backup_dir"
    fi
}

# Add file to dotfiles management
add_to_dotfiles() {
    local file_path="$1"
    
    if [ -z "$file_path" ]; then
        error "File path required"
        return 1
    fi
    
    # Resolve full path
    file_path=$(realpath "$file_path")
    
    if [ ! -e "$file_path" ]; then
        error "File does not exist: $file_path"
        return 1
    fi
    
    # Determine where to place it in dotfiles structure
    local filename
    filename=$(basename "$file_path")
    local target_dir=""
    
    case "$filename" in
        .bashrc|.bash_profile|.bash_aliases)
            target_dir="$DOTFILES_DIR/shells/bash"
            ;;
        .zshrc|.zsh_profile)
            target_dir="$DOTFILES_DIR/shells/zsh"
            ;;
        .gitconfig|.gitignore_global)
            target_dir="$DOTFILES_DIR/apps/git"
            ;;
        .tmux.conf)
            target_dir="$DOTFILES_DIR/apps/tmux"
            ;;
        .vimrc|.nvimrc)
            target_dir="$DOTFILES_DIR/apps/nvim"
            ;;
        *)
            read -p "Enter target directory (relative to $DOTFILES_DIR): " target_dir
            target_dir="$DOTFILES_DIR/$target_dir"
            ;;
    esac
    
    if [ -z "$target_dir" ]; then
        error "Could not determine target directory"
        return 1
    fi
    
    # Create target directory
    mkdir -p "$target_dir"
    
    # Move file to dotfiles directory
    local target_file="$target_dir/$(basename "$filename" | sed 's/^\.//')"
    
    log "Moving $file_path to $target_file"
    mv "$file_path" "$target_file"
    
    # Create symlink back to original location
    if command -v create_symlink >/dev/null 2>&1; then
        create_symlink "$target_file" "$file_path" true false
    else
        ln -s "$target_file" "$file_path"
    fi
    
    success "Added $filename to dotfiles management"
    log "File: $target_file"
    log "Symlink: $file_path"
}

# Run system diagnostics
run_doctor() {
    echo -e "${BLUE}Dotfiles System Diagnostics${NC}"
    echo "============================"
    
    local issues=0
    
    # Check directory structure
    echo -e "\n${BLUE}Directory Structure:${NC}"
    local required_dirs=("$DOTFILES_DIR" "$SCRIPTS_DIR" "$LIB_DIR" "$CONFIG_DIR/install")
    for dir in "${required_dirs[@]}"; do
        if [ -d "$dir" ]; then
            success "$dir"
        else
            error "Missing: $dir"
            ((issues++))
        fi
    done
    
    # Check required files
    echo -e "\n${BLUE}Required Files:${NC}"
    local required_files=(
        "$LIB_DIR/backup-manager.sh"
        "$LIB_DIR/machine-detector.sh"
        "$LIB_DIR/symlink-manager.sh"
        "$LIB_DIR/secret-manager.sh"
        "$CONFIG_DIR/install/install.sh"
    )
    
    for file in "${required_files[@]}"; do
        if [ -f "$file" ]; then
            success "$(basename "$file")"
        else
            error "Missing: $file"
            ((issues++))
        fi
    done
    
    # Check Git repository
    echo -e "\n${BLUE}Git Repository:${NC}"
    if is_git_repo; then
        success "Git repository initialized"
        
        # Check remote
        if git -C "$CONFIG_DIR" remote -v | grep -q origin; then
            success "Remote origin configured"
        else
            warn "No remote origin configured"
        fi
    else
        error "Not a git repository"
        ((issues++))
    fi
    
    # Check symlinks
    echo -e "\n${BLUE}Symlinks:${NC}"
    if command -v verify_symlinks >/dev/null 2>&1; then
        if verify_symlinks >/dev/null 2>&1; then
            success "All symlinks verified"
        else
            error "Symlink verification failed"
            ((issues++))
        fi
    else
        warn "Symlink verification not available"
    fi
    
    # Check PATH
    echo -e "\n${BLUE}PATH Configuration:${NC}"
    if [[ ":$PATH:" == *":$HOME/.local/bin:"* ]]; then
        success "~/.local/bin in PATH"
    else
        warn "~/.local/bin not in PATH"
    fi
    
    if [[ ":$PATH:" == *":$SCRIPTS_DIR/bin:"* ]]; then
        success "Scripts directory in PATH"
    else
        warn "Scripts directory not in PATH"
    fi
    
    # Check shell configuration
    echo -e "\n${BLUE}Shell Configuration:${NC}"
    if [ -f "$HOME/.bashrc" ] && [ -L "$HOME/.bashrc" ]; then
        success "Bashrc managed"
    else
        warn "Bashrc not managed or not symlinked"
    fi
    
    # Check dependencies
    echo -e "\n${BLUE}Dependencies:${NC}"
    local deps=(git curl jq)
    for dep in "${deps[@]}"; do
        if command -v "$dep" >/dev/null 2>&1; then
            success "$dep installed"
        else
            error "$dep not found"
            ((issues++))
        fi
    done
    
    # Summary
    echo -e "\n${BLUE}Summary:${NC}"
    if [ $issues -eq 0 ]; then
        success "All checks passed!"
    else
        error "$issues issues found"
        log "Run: dotfiles install --help for installation instructions"
    fi
    
    return $issues
}

# Show system information
show_info() {
    echo -e "${BLUE}Dotfiles System Information${NC}"
    echo "=========================="
    
    echo "Version: $VERSION"
    echo "Config Directory: $CONFIG_DIR"
    echo "Shell: $SHELL"
    echo "OS: $(uname -s) $(uname -r)"
    
    if command -v get_machine_value >/dev/null 2>&1; then
        echo -e "\n${BLUE}Machine Profile:${NC}"
        echo "ID: $(get_machine_value machine_id)"
        echo "OS: $(get_machine_value os)"
        echo "Distro: $(get_machine_value distro)"
        echo "Version: $(get_machine_value version)"
        echo "Role: $(get_machine_value role)"
        echo "WSL: $(get_machine_value is_wsl)"
    fi
    
    if is_git_repo; then
        echo -e "\n${BLUE}Git Information:${NC}"
        echo "Branch: $(git -C "$CONFIG_DIR" branch --show-current 2>/dev/null || echo "unknown")"
        echo "Remote: $(git -C "$CONFIG_DIR" remote get-url origin 2>/dev/null || echo "none")"
        echo "Last commit: $(git -C "$CONFIG_DIR" log -1 --format="%h %s" 2>/dev/null || echo "none")"
    fi
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        status)
            show_status
            ;;
        sync)
            sync_dotfiles "$@"
            ;;
        backup)
            if command -v backup_main >/dev/null 2>&1; then
                backup_main "$@"
            else
                backup_dotfiles "$@"
            fi
            ;;
        restore)
            if command -v backup_main >/dev/null 2>&1; then
                backup_main restore "$@"
            else
                error "Backup manager not available"
            fi
            ;;
        diff)
            if is_git_repo; then
                git -C "$CONFIG_DIR" diff "$@"
            else
                error "Not a git repository"
            fi
            ;;
        add)
            add_to_dotfiles "$@"
            ;;
        machine)
            if command -v machine_main >/dev/null 2>&1; then
                machine_main "$@"
            else
                error "Machine detector not available"
            fi
            ;;
        test|validate)
            run_doctor
            ;;
        install)
            if [ -x "$CONFIG_DIR/install/install.sh" ]; then
                "$CONFIG_DIR/install/install.sh" "$@"
            else
                error "Installer not found"
            fi
            ;;
        update)
            log "Updating dotfiles system..."
            sync_dotfiles
            if command -v verify_symlinks >/dev/null 2>&1; then
                verify_symlinks
            fi
            success "Update complete"
            ;;
        clean)
            if command -v cleanup_symlinks >/dev/null 2>&1; then
                cleanup_symlinks "$@"
            fi
            if command -v backup_main >/dev/null 2>&1; then
                backup_main clean 30
            fi
            ;;
        secrets)
            if command -v secrets_main >/dev/null 2>&1; then
                secrets_main "$@"
            else
                error "Secret manager not available"
            fi
            ;;
        scripts)
            local script_cmd="${1:-list}"
            case "$script_cmd" in
                list)
                    log "Available scripts:"
                    if [ -d "$SCRIPTS_DIR/bin" ]; then
                        ls -la "$SCRIPTS_DIR/bin"
                    else
                        warn "No scripts directory found"
                    fi
                    ;;
                add)
                    error "Script addition not yet implemented"
                    ;;
                *)
                    error "Unknown scripts command: $script_cmd"
                    ;;
            esac
            ;;
        links)
            if command -v symlink_main >/dev/null 2>&1; then
                symlink_main "$@"
            else
                error "Symlink manager not available"
            fi
            ;;
        info)
            show_info
            ;;
        doctor)
            run_doctor
            ;;
        version)
            echo "dotfiles version $VERSION"
            ;;
        help|--help)
            show_help
            ;;
        *)
            error "Unknown command: $command"
            echo
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"